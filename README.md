# CreditorWatch Interview

## The Task

> The CEO from CreditorWatch is very interested in SEO and how this can improve Sales. Every
> morning he logs into google.com.au and types in the same key words “creditorwatch” and
> counts down to see where and how many times the company, www.creditorwatch.com.au
> appears.
>
> Seeing the CEO do this every day, a smart software developer at CreditorWatch decides to
> write a small application for him that will automatically perform this operation and return the
> result to the screen. They design and code some software that receives a string of keywords
> (E.G. “creditorwatch”) and a URL (E.G. “www.creditorwatch.com.au”). This is then processed to
> return a list of numbers for where the resulting URL is found in the Google results.
>
> For example, “1, 10, 33” or “0”
>
> The CEO is only interested if their URL appears in the first 100 results.

## Running the project

This project uses docker and all configuration is stored in the docker directory.

To launch the project run the following from the root directory:

```
docker-compose up
```

The project will then be served at http://localhost:8080

## Testing the project

Tests are located in the tests directory and can be run using the following:

```
docker-compose exec php sh -c "cd /var/www/html/tests/ && php run.php"
```

## Configuring the project

This project makes use of the Google Custom Search API. 

Tokens generated by Google should be stored in the `app/config/app.php` file. 

See [Google Custom Search](https://developers.google.com/custom-search/docs/overview) for more information.

## Project Analysis

This project makes use of several design patterns which are intended to make the codebase flexible and easy to extend in the future. In this section we will discuss how the project works and the reasons why particular design patterns were chosen.

### Project Structure

#### app
Contains all code which relates to the project organised in subfolders.

#### CreditorWatch
Contains all application classes used in the project. Follows namespacing convention.

#### CreditorWatch/Log
Contains classes which control application level logging. 

Currently only logging to a file is supported however the AbstractLog class allows this to be extended without affecting existing log statements throughout the application.

#### CreditorWatch/Parser
Contains classes which control parsing responses.

Currently only Json response are supported however the ParserInterface ensures a common API for parsing other responses be it XML, CSV or plain text. 

It was decided to decouple the parser from the Transport class as there may be cases when you want to parse content without any underlying transport call occurring. This is also useful for unit testing.

#### CreditorWatch/Processor
Contains classes which interpret the search engine results. Could otherwise be described as "business logic" but is not limited to business logic.

#### CreditorWatch/SearchEngine
Contains classes which implement a specific search engine. 

All search engines are based off the AbstractSearchEngine which ensures a common API. This allows for future implementations to switch between search engines at run time.

The search engine classes make use of the Strategy design pattern.

#### CreditorWatch/System
Contains classes specific to the application framework. 

The App class makes use of the Singleton design pattern. 

#### CreditorWatch/Transport
Contains classes specific to making requests and receiving responses for a given protocol.

Currently the only protocol used is HTTP. The TransportInterface ensures that future protocols will have a common API and classes interacting with them will not be concerned about how the information is retrieved.

To aid the Strategy pattern used in the search engines, the TransportInterface makes use of the Factory Method design pattern.

#### config
Contains application level configuration.

#### logs
Default directory for application level logs.

#### public
Web server document root. 

Minimises tampering of application code by preventing direct access to all app folders. Also contains public assets such as api endpoints, images, javascript and css.

#### tests
Contains unit tests for the application.

#### bootstrap.php
Bootstraps the application so classes are all reachable when they are instantiated.

#### docker
Contains docker specific configuration needed when serving the application.

#### docker-compose.yml
Contains instructions on how docker will serve the application.

### Design Patterns

From the previous section we have identified a variety of design patterns that are used in this project. This section will delve into why they were chosen and how they should be used.

At a high level, the application works by constructing an entity (in this case, a search engine) using a transport strategy and a parser strategy. The entity is then queried and the results are processed to interpret business value.

#### Strategy Pattern

The Strategy pattern was identified as a crucial foundation for the operation of the application. It's use is mostly low level to allow other classes to make use of any given transport method without any modification to their internal mechanisms.

This is extremely extensible as it allows objects to mix and match transport and parsing strategies. Using this extensibility we can construct entities which have combinations of HTTP(S), SSH, IMAP, LDAP protocols with JSON, CSV, XML, YAML or Plain Text responses. 

This list is by no means complete and even with a few protocols and parsers the, combinatorial effect is huge and beneficial to code reuse.

Another reason this design pattern is so useful is that the entity we are querying does not need to be a search engine. The CEO at a later date may decide that newspaper articles stored on an FTP server are all the rage and (s)he must know how many business articles mention CreditorWatch.

#### Singleton Pattern

The Singleton pattern is mainly used within the application framework. Having one instance of the application is generally good practice and reduces cognitive load.

By using this pattern the application instance can be requested at any time in any part of the framework and each library can be certain they are all receiving a common object and specifically, common application state.

Another advantage of this pattern is in regards to shared resources. If two areas of the codebase try to write to a log file at the same time there could be consequences. Imagine writing something to the log in one class and a concurrent class closes the file you are writing to. Using the Singleton pattern we can ensure that every line logged is going through a central class which can ensure that changes are made safely.

A further example of why common state is important is using the configuration file. We want a single configuration file to be distributed to all classes which need it. This employs the DRY principal in that when things change only one place needs to be updated. If config parameters are changed during runtime and the application does not use the Singleton pattern, you would quickly find inconsistencies scattered throughout your application.

#### Factory Method Pattern

The Factory Method pattern is mainly used to aid the Strategy pattern. The search engines are provided with a transport and parser strategy however they are unaware of which object they hold until runtime.

To simplify this, the TransportInterface states that concrete classes must implement a makeRequest function. When implementing a Transport class such as Http we can be fairly certain that a HttpRequest is required. Building this into the Http class (and broader transport interface) allows the receiver of these objects to call a common API function and know that the object returned will be compatible with the Transport strategy.

Further use of the factory method later on would be to produce strategies to pass into classes based on some given input. This would allow a user to build their own objects during runtime through a friendly UI without even knowing it. 

#### Chain of Responsibility Design Pattern
Although not implemented in this project, the Chain of Responsibility design patter is a good candidate for the Processor module. Allowing processors to be chained together will allow a series of operations to be performed on one set of results from Google. The CEO may wish to extract out other metadata from the search results and using this design pattern will greatly simplify adding extra operations to interpreting the results.

For example, the CEO may request that in addition to determining the rank of the CreditorWatch website amongst the results, (s)he would also like a report of which results are outranking CreditorWatch. Instead of traversing the results multiple times for each operation, we can pass the result set down the chain and let the linked classes operate on that information as needed. This is similar to the Decorator pattern in some respect.

## Production Considerations

As this project is a hypothetical scenario, there are many aspects of it which should be considered before any production implementation. We will discuss these here.

### Docker configuration
This project uses docker for rapid development however the images used are completely out of the box functionality. Some effort should be made to ensure that a production ready, hardened, secure image is produced prior to deployment. Further to this these images should be generated automatically by a build system to ensure repeatable and well tested docker images.

### Environment configuration
This project makes no use of environment configurations. In the real world, we would need at least a dev, test and production environment where each one is configured slightly differently. For example, debug logging would not be needed in a production environment however is very useful for a developer creating a new feature. These environment configurations usually follow an inheritence model where a base config is overridden with values relating to a specific environment. A good example of this is separating database connections between environments or API keys.

### Unit testing
Extra unit testing is recommended specifically around the interfaces of classes to ensure no edge cases are present before deployment to production. This project has provided some unit tests however it is by no means complete coverage and does not include mock tests which would be highly recommened.  

### Cost Vs Effort
Again this is a hypothetical situation, however it does raise the concern as to the benefit of a developer creating an application which interprets Google search results for rankings. It may be faster, cheaper and easier for all involved to simply use Google Analytics or equivalent tool to determine the state of the companies online presence. Alternatively this may very well be an excellent solution to the wrong question. 

### Use of frameworks & libraries
One of the requirements of this project prevented any use of frameworks. It would be recommended to use battle tested frameworks and libraries to avoid bugs and save developer man hours. The application avoids using any complex routing for this purpose, a proper MVC framework would allow you to spend more time on the problem domain rather than dealing with HTTP requests and responses. Furthermore, a full featured unit testing framework will ensure that the code can be tested in all scenarios.

Potential libraries that could be used would be:
  * Laravel/Symfony/Yii for the application framework
  * Monolog for the logging service
  * Guzzle for HTTP communications
  * jQuery/Vue.js/React for frontend components
  * Sass/Less for CSS compilation
  * PHPUnit/Codeception for unit testing

### Application robustness
This application has plenty of room for added robustness. Exceptions are scarce, validation is almost non-existent and protecting the users security from attackers has not been addressed. Prior to production depoyment, at the very least, security concerns must be addressed. Html output should be careful to avoid XSS and input to the application should be cleaned of any malicious data.

### Optimisation
This application also has room for some optimisation. CSS and JS are not minified or concatenated (not that there are multiple files). No caches have been used, queries are not stored and make no attempt to prevent Google API daily limit exhaustion  . No benchmarks or timings have been made for the API, it is recommended to log api execution timings for use in monitoring/alerting.

### Monitoring and Alerting
No effort has been made in regard to monitoring and alerting the application health. Production deployments in general require robust monitoring to ensure prompt action when the service requires intervention.

### Storage
No long term storage has been used in this application. It may be beneficial if information is stored to allow for future processing or retrospective needs. One example that comes to mind is charting the ranking of search terms over time. This would allow the CEO to understand how changes in marketing strategy affect the ranking on Google.

### Job scheduling
Another consideration for production may be the use of a job schedule or messaging queue. The application could be set up to query a specific set of keyword and target URLs periodically or in response to an event which would change how the CEO would interact with the application. If the query can be automated, the application may end up as a dashboard on a monitor in the office and require only a glance to see the results.

## Conclusion

Design patterns are a tried and tested way to solve a variety of common problems. Using them ensures that developers have a clear understanding of how to extend a system within the framework provided and allows for clean, testable and reusable code.

If you got this far, thank you for reading. 
